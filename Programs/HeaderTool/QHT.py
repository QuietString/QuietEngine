#!/usr/bin/env python3
# QHeaderTool (QHT): per-module header generator for QPROPERTY/QFUNCTION markers.
# Emits a single header per module with inline invokers and a QHT_Register_<Unit>(Registry&).

import argparse, re
from pathlib import Path

CLASS_RE = re.compile(r"\b(class|struct)\s+(?P<name>[A-Za-z_]\w*)\s*(?:[:][^{]+)?\{", re.M)
COMMENT_SL = re.compile(r"//.*?$", re.M)
COMMENT_ML = re.compile(r"/\*.*?\*/", re.S)
PROP_RE = re.compile(r"QPROPERTY\s*(?:\((?P<meta>[^)]*)\))?\s*(?P<decl>[^;{]+);", re.M)
FUNC_RE = re.compile(r"QFUNCTION\s*(?:\((?P<meta>[^)]*)\))?\s*(?P<sig>(?P<ret>[A-Za-z_][^\s(]*[^\s]*)\s+(?P<name>[A-Za-z_]\w*)\s*\((?P<params>[^)]*)\)\s*(?:const\s*)?(?:;|\{))", re.M)
PARAM_SPLIT = re.compile(r",(?![^<]*>)")

def strip_comments(src: str) -> str:
    src = COMMENT_ML.sub("\n", src)
    src = COMMENT_SL.sub("", src)
    return src

def parse_meta_list(meta: str):
    result = []
    if not meta:
        return result
    tokens = [m.group(0) for m in re.finditer(r"\w+\s*=\s*\"[^\"]*\"|\w+\s*=\s*[^,]+|\w+", meta)]
    for t in tokens:
        if "=" in t:
            k, v = t.split("=", 1)
            result.append((k.strip(), v.strip().strip('"')))
        else:
            result.append((t.strip(), "true"))
    return result

class Property:
    def __init__(self, type_str, name, meta_items):
        self.type = type_str.strip()
        self.name = name.strip()
        self.meta = meta_items

class Function:
    def __init__(self, ret_type, name, params, meta_items):
        self.ret = ret_type.strip()
        self.name = name.strip()
        self.params = params
        self.meta = meta_items

class ClassInfo:
    def __init__(self, name):
        self.name = name
        self.properties = []
        self.functions = []
    def has_any(self):
        return bool(self.properties or self.functions)

def split_params(params_str: str):
    params_str = params_str.strip()
    if not params_str:
        return []
    parts = [p.strip() for p in PARAM_SPLIT.split(params_str)]
    out = []
    for p in parts:
        p = re.sub(r"\s*=.*$", "", p)
        if not p:
            continue
        toks = p.split()
        if len(toks) == 1:
            out.append((toks[0], ""))
        else:
            name = toks[-1]
            type_str = p[:p.rfind(name)].strip()
            out.append((type_str, name))
    return out

def find_classes(src: str):
    pos = 0
    while True:
        m = CLASS_RE.search(src, pos)
        if not m:
            break
        name = m.group('name')
        start = m.end()
        brace = 1
        i = start
        while i < len(src) and brace > 0:
            if src[i] == '{':
                brace += 1
            elif src[i] == '}':
                brace -= 1
            i += 1
        body = src[start:i-1]
        yield name, body
        pos = i

def scan_file(path: Path):
    raw = path.read_text(encoding='utf-8', errors='ignore')
    src = strip_comments(raw)
    classes = []
    for cname, body in find_classes(src):
        ci = ClassInfo(cname)
        for pm in PROP_RE.finditer(body):
            meta_s = pm.group('meta')
            decl = pm.group('decl').strip()
            decl = decl.split('=')[0].strip()            # drop initializer
            decl = re.sub(r"^\s*static\s+", "", decl) # drop static
            toks = decl.split()
            if not toks:
                continue
            name = toks[-1]
            type_str = decl[:decl.rfind(name)].strip()
            ci.properties.append(Property(type_str, name, parse_meta_list(meta_s)))
        for fm in FUNC_RE.finditer(body):
            meta_s = fm.group('meta')
            ret = fm.group('ret')
            fname = fm.group('name')
            params = split_params(fm.group('params'))
            ci.functions.append(Function(ret, fname, params, parse_meta_list(meta_s)))
        if ci.has_any():
            classes.append(ci)
    return classes

HEADER_H = r"""// Auto-generated by QHT. Do not edit.
#pragma once
#include <cstddef>
#include <vector>
#include <string>
#include <unordered_map>
#include "qmeta_runtime.h"
using namespace qmeta;
"""

def emit_header(classes, out_path: Path, unit: str):
    lines = [HEADER_H, f"// Unit: {unit}\n\n"]
    for ci in classes:
        cname = ci.name
        for fn in ci.functions:
            args_extract = []
            for idx, (ptype, pname) in enumerate(fn.params):
                args_extract.append(f"    {ptype} a{idx} = args[{idx}].as<{ptype}>();\n")
            call_args = ", ".join([f"a{i}" for i in range(len(fn.params))])
            inv_name = f"_qmeta_invoke_{cname}_{fn.name}"
            if fn.ret.strip() == "void":
                body = (f"static inline Variant {inv_name}(void* obj, const Variant* args, std::size_t) {{\n"
                        f"    {cname}* self = static_cast<{cname}*>(obj);\n"
                        + "".join(args_extract) +
                        (f"    self->{fn.name}({call_args});\n" if call_args else f"    self->{fn.name}();\n") +
                        f"    return Variant();\n}}\n\n")
            else:
                body = (f"static inline Variant {inv_name}(void* obj, const Variant* args, std::size_t) {{\n"
                        f"    {cname}* self = static_cast<{cname}*>(obj);\n"
                        + "".join(args_extract) +
                        f"    auto _ret = self->{fn.name}({call_args});\n"
                        f"    return Variant(_ret);\n}}\n\n")
            lines.append(body)

    lines.append(f"inline void QHT_Register_{unit}(Registry& R) {{\n")
    for ci in classes:
        cname = ci.name
        lines.append(f"    TypeInfo& T_{cname} = R.add_type(\"{cname}\", sizeof({cname}));\n")
        for p in ci.properties:
            meta_items = ", ".join([f"std::make_pair(std::string(\"{k}\"), std::string(\"{v}\"))" for k,v in p.meta])
            meta_code = f"MetaMap{{ {meta_items} }}" if meta_items else "MetaMap{}"
            lines.append(
                f"    T_{cname}.properties.push_back(MetaProperty{{\"{p.name}\", \"{p.type}\", offsetof({cname}, {p.name}), {meta_code} }});\n"
            )
        for f in ci.functions:
            params_vec = ", ".join([f"MetaParam{{\"{pn}\", \"{pt}\"}}" for (pt,pn) in f.params])
            meta_items = ", ".join([f"std::make_pair(std::string(\"{k}\"), std::string(\"{v}\"))" for k,v in f.meta])
            meta_code = f"MetaMap{{ {meta_items} }}" if meta_items else "MetaMap{}"
            inv_name = f"_qmeta_invoke_{cname}_{f.name}"
            lines.append("    {\n")
            lines.append( "        MetaFunction F;\n")
            lines.append(f"        F.name = \"{f.name}\";\n")
            lines.append(f"        F.return_type = \"{f.ret}\";\n")
            lines.append(f"        F.invoker = &{inv_name};\n")
            lines.append(f"        F.params = std::vector<MetaParam>{{ {params_vec} }};\n")
            lines.append(f"        F.meta = {meta_code};\n")
            lines.append( "        T_{cname}.functions.push_back(std::move(F));\n".replace("{cname}", cname))
            lines.append( "    }\n")
    lines.append("}\n")

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("".join(lines), encoding="utf-8")

if __name__ == '__main__':
    ap = argparse.ArgumentParser()
    ap.add_argument('--unit', required=True, help='Module name: Engine or Game')
    ap.add_argument('--src', required=True, help='Semicolon-separated source dirs to scan')
    ap.add_argument('--out', required=True, help='Output header path (*.qht.gen.hpp)')
    args = ap.parse_args()

    src_dirs = [Path(p) for p in args.src.split(';') if p]
    classes = []
    for sd in src_dirs:
        for ext in (".h", ".hpp", ".hh"):
            for p in sd.rglob(f"*{ext}"):
                classes.extend(scan_file(p))

    emit_header(classes, Path(args.out), args.unit)