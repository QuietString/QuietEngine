// Auto-generated by QHT. Do not edit.
#pragma once
#include <cstddef>
#include <vector>
#include <string>
#include <unordered_map>
#include <stdexcept>
#include "qmeta_runtime.h"
using namespace qmeta;
// Unit: Engine

#include "Actor.h"
#include "Character.h"
#include "Object.h"
#include "World.h"

static Variant _qmeta_invoke_QActor_SetActorInteger(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QActor*>(Self);
    if (argc < 1) throw std::runtime_error("QActor::SetActorInteger requires 1 args");
    auto _a0 = args[0].as<int>();
    self->SetActorInteger(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QActor_GetOwner(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QActor*>(Self);
    auto _ret = self->GetOwner();
    return Variant(_ret);
}

static Variant _qmeta_invoke_QActor_SetOwner(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QActor*>(Self);
    if (argc < 1) throw std::runtime_error("QActor::SetOwner requires 1 args");
    auto _a0 = args[0].as<QActor*>();
    self->SetOwner(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QWorld_AddObject(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QWorld*>(Self);
    if (argc < 1) throw std::runtime_error("QWorld::AddObject requires 1 args");
    auto _a0 = args[0].as<std::string>();
    self->AddObject(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QWorld_RemoveObject(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QWorld*>(Self);
    if (argc < 1) throw std::runtime_error("QWorld::RemoveObject requires 1 args");
    auto _a0 = args[0].as<std::string>();
    self->RemoveObject(_a0);
    return Variant();
}

inline void QHT_Register_Engine(Registry& R) {
    TypeInfo& T_QActor = R.add_type("QActor", sizeof(QActor));
    T_QActor.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Engine")) };
    T_QActor.base_name = "QObject";
    T_QActor.properties.push_back(MetaProperty{"ActorInteger", "int", offsetof(QActor, ActorInteger), MetaMap{} });
    T_QActor.properties.push_back(MetaProperty{"Owner", "QActor*", offsetof(QActor, Owner), MetaMap{} });
    {
        MetaFunction F;
        F.name = "SetActorInteger";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QActor_SetActorInteger;
        F.params = std::vector<MetaParam>{ MetaParam{"InValue", "int"} };
        F.meta = MetaMap{};
        T_QActor.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "GetOwner";
        F.return_type = "QActor*";
        F.invoker = &_qmeta_invoke_QActor_GetOwner;
        F.params = std::vector<MetaParam>{  };
        F.meta = MetaMap{};
        T_QActor.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "SetOwner";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QActor_SetOwner;
        F.params = std::vector<MetaParam>{ MetaParam{"InOwner", "QActor*"} };
        F.meta = MetaMap{};
        T_QActor.functions.push_back(std::move(F));
    }
    TypeInfo& T_QCharacter = R.add_type("QCharacter", sizeof(QCharacter));
    T_QCharacter.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Engine")) };
    T_QCharacter.base_name = "QActor";
    T_QCharacter.properties.push_back(MetaProperty{"Health", "int", offsetof(QCharacter, Health), MetaMap{} });
    T_QCharacter.properties.push_back(MetaProperty{"TestValue", "float", offsetof(QCharacter, TestValue), MetaMap{} });
    TypeInfo& T_QObject = R.add_type("QObject", sizeof(QObject));
    T_QObject.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Engine")) };
    T_QObject.base_name = "QObjectBase";
    TypeInfo& T_QWorld = R.add_type("QWorld", sizeof(QWorld));
    T_QWorld.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Engine")) };
    T_QWorld.base_name = "QObject";
    T_QWorld.properties.push_back(MetaProperty{"Objects", "std::vector<QObject*>", offsetof(QWorld, Objects), MetaMap{} });
    {
        MetaFunction F;
        F.name = "AddObject";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QWorld_AddObject;
        F.params = std::vector<MetaParam>{ MetaParam{"ObjName", "const std::string&"} };
        F.meta = MetaMap{};
        T_QWorld.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "RemoveObject";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QWorld_RemoveObject;
        F.params = std::vector<MetaParam>{ MetaParam{"ObjName", "const std::string&"} };
        F.meta = MetaMap{};
        T_QWorld.functions.push_back(std::move(F));
    }
}
