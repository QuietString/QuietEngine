// Auto-generated by QHT. Do not edit.
#pragma once
#include <cstddef>
#include <vector>
#include <string>
#include <unordered_map>
#include <stdexcept>
#include "qmeta_runtime.h"
using namespace qmeta;
// Unit: Game

#include "Test/GcTester.h"

static Variant _qmeta_invoke_QGcTester_PatternChain(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 2) throw std::runtime_error("QGcTester::PatternChain requires 2 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    self->PatternChain(_a0, _a1);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternGrid(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternGrid requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternGrid(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternRandom(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternRandom requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternRandom(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternRings(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternRings requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternRings(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternDiamond(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternDiamond requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternDiamond(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_ClearAll(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    self->ClearAll();
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_BreakAtDepth(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::BreakAtDepth requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    auto _ret = self->BreakAtDepth(_a0, _a1, _a2);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_BreakPercent(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::BreakPercent requires 3 args");
    auto _a0 = args[0].as<double>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    auto _ret = self->BreakPercent(_a0, _a1, _a2);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_BreakRandomEdges(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 2) throw std::runtime_error("QGcTester::BreakRandomEdges requires 2 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _ret = self->BreakRandomEdges(_a0, _a1);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_DetachRoots(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 2) throw std::runtime_error("QGcTester::DetachRoots requires 2 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<double>();
    auto _ret = self->DetachRoots(_a0, _a1);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_PrintDepthStats(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 1) throw std::runtime_error("QGcTester::PrintDepthStats requires 1 args");
    auto _a0 = args[0].as<int>();
    self->PrintDepthStats(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_MeasureGc(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 1) throw std::runtime_error("QGcTester::MeasureGc requires 1 args");
    auto _a0 = args[0].as<int>();
    self->MeasureGc(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_Churn(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 5) throw std::runtime_error("QGcTester::Churn requires 5 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<double>();
    auto _a3 = args[3].as<int>();
    auto _a4 = args[4].as<int>();
    self->Churn(_a0, _a1, _a2, _a3, _a4);
    return Variant();
}

inline void QHT_Register_Game(Registry& R) {
    TypeInfo& T_QGcTester = R.add_type("QGcTester", sizeof(QGcTester));
    T_QGcTester.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Game")) };
    T_QGcTester.properties.push_back(MetaProperty{"Roots", "std::vector<QObject*>", offsetof(QGcTester, Roots), MetaMap{} });
    {
        MetaFunction F;
        F.name = "PatternChain";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternChain;
        F.params = std::vector<MetaParam>{ MetaParam{"Length", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternGrid";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternGrid;
        F.params = std::vector<MetaParam>{ MetaParam{"Width", "int"}, MetaParam{"Height", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternRandom";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternRandom;
        F.params = std::vector<MetaParam>{ MetaParam{"Nodes", "int"}, MetaParam{"AvgOut", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternRings";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternRings;
        F.params = std::vector<MetaParam>{ MetaParam{"Rings", "int"}, MetaParam{"RingSize", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternDiamond";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternDiamond;
        F.params = std::vector<MetaParam>{ MetaParam{"Layers", "int"}, MetaParam{"Breadth", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "ClearAll";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_ClearAll;
        F.params = std::vector<MetaParam>{  };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "BreakAtDepth";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_BreakAtDepth;
        F.params = std::vector<MetaParam>{ MetaParam{"TargetDepth", "int"}, MetaParam{"Count", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "BreakPercent";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_BreakPercent;
        F.params = std::vector<MetaParam>{ MetaParam{"Percent", "double"}, MetaParam{"Depth", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "BreakRandomEdges";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_BreakRandomEdges;
        F.params = std::vector<MetaParam>{ MetaParam{"EdgeCount", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "DetachRoots";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_DetachRoots;
        F.params = std::vector<MetaParam>{ MetaParam{"Count", "int"}, MetaParam{"Ratio", "double"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PrintDepthStats";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PrintDepthStats;
        F.params = std::vector<MetaParam>{ MetaParam{"TargetDepth", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "MeasureGc";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_MeasureGc;
        F.params = std::vector<MetaParam>{ MetaParam{"Repeats", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "Churn";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_Churn;
        F.params = std::vector<MetaParam>{ MetaParam{"Steps", "int"}, MetaParam{"AllocPerStep", "int"}, MetaParam{"BreakPct", "double"}, MetaParam{"GcEveryN", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
}
