// Auto-generated by QHT. Do not edit.
#pragma once
#include <cstddef>
#include <vector>
#include <string>
#include <unordered_map>
#include <stdexcept>
#include "qmeta_runtime.h"
using namespace qmeta;
// Unit: Game

#include "Classes/Monster.h"
#include "Classes/Player.h"
#include "Test/GcTester.h"
#include "Test/TestObject.h"

static Variant _qmeta_invoke_QMonster_GetHealth(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QMonster*>(Self);
    auto _ret = self->GetHealth();
    return Variant(_ret);
}

static Variant _qmeta_invoke_QMonster_SetHealth(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QMonster*>(Self);
    if (argc < 1) throw std::runtime_error("QMonster::SetHealth requires 1 args");
    auto _a0 = args[0].as<int>();
    self->SetHealth(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QMonster_IsDead(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QMonster*>(Self);
    auto _ret = self->IsDead();
    return Variant(_ret);
}

static Variant _qmeta_invoke_QMonster_TakeDamage(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QMonster*>(Self);
    if (argc < 1) throw std::runtime_error("QMonster::TakeDamage requires 1 args");
    auto _a0 = args[0].as<int>();
    self->TakeDamage(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QMonster_GetTarget(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QMonster*>(Self);
    auto _ret = self->GetTarget();
    return Variant(_ret);
}

static Variant _qmeta_invoke_QMonster_SetTarget(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QMonster*>(Self);
    if (argc < 1) throw std::runtime_error("QMonster::SetTarget requires 1 args");
    auto _a0 = args[0].as<QActor*>();
    self->SetTarget(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QPlayer_SetWalkSpeed(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QPlayer*>(Self);
    if (argc < 1) throw std::runtime_error("QPlayer::SetWalkSpeed requires 1 args");
    auto _a0 = args[0].as<float>();
    self->SetWalkSpeed(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_SetUseVector(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 1) throw std::runtime_error("QGcTester::SetUseVector requires 1 args");
    auto _a0 = args[0].as<bool>();
    self->SetUseVector(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternChain(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 2) throw std::runtime_error("QGcTester::PatternChain requires 2 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    self->PatternChain(_a0, _a1);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternGrid(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternGrid requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternGrid(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternRandom(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternRandom requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternRandom(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternRings(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternRings requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternRings(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_PatternDiamond(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::PatternDiamond requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->PatternDiamond(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_ClearAll(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 1) throw std::runtime_error("QGcTester::ClearAll requires 1 args");
    auto _a0 = args[0].as<bool>();
    self->ClearAll(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_BreakAtDepth(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::BreakAtDepth requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    auto _ret = self->BreakAtDepth(_a0, _a1, _a2);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_BreakPercent(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 4) throw std::runtime_error("QGcTester::BreakPercent requires 4 args");
    auto _a0 = args[0].as<double>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    auto _a3 = args[3].as<bool>();
    auto _ret = self->BreakPercent(_a0, _a1, _a2, _a3);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_BreakRandomEdges(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 2) throw std::runtime_error("QGcTester::BreakRandomEdges requires 2 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _ret = self->BreakRandomEdges(_a0, _a1);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_DetachRoots(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 2) throw std::runtime_error("QGcTester::DetachRoots requires 2 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<double>();
    auto _ret = self->DetachRoots(_a0, _a1);
    return Variant(_ret);
}

static Variant _qmeta_invoke_QGcTester_PrintDepthStats(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 1) throw std::runtime_error("QGcTester::PrintDepthStats requires 1 args");
    auto _a0 = args[0].as<int>();
    self->PrintDepthStats(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_MeasureGc(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 1) throw std::runtime_error("QGcTester::MeasureGc requires 1 args");
    auto _a0 = args[0].as<int>();
    self->MeasureGc(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_Churn(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 5) throw std::runtime_error("QGcTester::Churn requires 5 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<double>();
    auto _a3 = args[3].as<int>();
    auto _a4 = args[4].as<int>();
    self->Churn(_a0, _a1, _a2, _a3, _a4);
    return Variant();
}

static Variant _qmeta_invoke_QGcTester_RepeatRandomAndCollect(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QGcTester*>(Self);
    if (argc < 3) throw std::runtime_error("QGcTester::RepeatRandomAndCollect requires 3 args");
    auto _a0 = args[0].as<int>();
    auto _a1 = args[1].as<int>();
    auto _a2 = args[2].as<int>();
    self->RepeatRandomAndCollect(_a0, _a1, _a2);
    return Variant();
}

static Variant _qmeta_invoke_QTestObject_SetInteger(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QTestObject*>(Self);
    if (argc < 1) throw std::runtime_error("QTestObject::SetInteger requires 1 args");
    auto _a0 = args[0].as<int>();
    self->SetInteger(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QTestObject_RemoveFriend(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QTestObject*>(Self);
    if (argc < 1) throw std::runtime_error("QTestObject::RemoveFriend requires 1 args");
    auto _a0 = args[0].as<int>();
    self->RemoveFriend(_a0);
    return Variant();
}

static Variant _qmeta_invoke_QTestObject_RemoveChildren(void* Self, const Variant* args, size_t argc) {
    (void)argc; auto* self = static_cast<QTestObject*>(Self);
    self->RemoveChildren();
    return Variant();
}

inline void QHT_Register_Game(Registry& R) {
    TypeInfo& T_QMonster = R.add_type("QMonster", sizeof(QMonster));
    T_QMonster.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Game")) };
    T_QMonster.base_name = "QActor";
    T_QMonster.properties.push_back(MetaProperty{"Health", "int", offsetof(QMonster, Health), MetaMap{} });
    T_QMonster.properties.push_back(MetaProperty{"Target", "QActor*", offsetof(QMonster, Target), MetaMap{} });
    {
        MetaFunction F;
        F.name = "GetHealth";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QMonster_GetHealth;
        F.params = std::vector<MetaParam>{  };
        F.meta = MetaMap{};
        T_QMonster.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "SetHealth";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QMonster_SetHealth;
        F.params = std::vector<MetaParam>{ MetaParam{"InHealth", "int"} };
        F.meta = MetaMap{};
        T_QMonster.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "IsDead";
        F.return_type = "bool";
        F.invoker = &_qmeta_invoke_QMonster_IsDead;
        F.params = std::vector<MetaParam>{  };
        F.meta = MetaMap{};
        T_QMonster.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "TakeDamage";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QMonster_TakeDamage;
        F.params = std::vector<MetaParam>{ MetaParam{"Damage", "int"} };
        F.meta = MetaMap{};
        T_QMonster.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "GetTarget";
        F.return_type = "QActor*";
        F.invoker = &_qmeta_invoke_QMonster_GetTarget;
        F.params = std::vector<MetaParam>{  };
        F.meta = MetaMap{};
        T_QMonster.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "SetTarget";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QMonster_SetTarget;
        F.params = std::vector<MetaParam>{ MetaParam{"InTarget", "QActor*"} };
        F.meta = MetaMap{};
        T_QMonster.functions.push_back(std::move(F));
    }
    TypeInfo& T_QPlayer = R.add_type("QPlayer", sizeof(QPlayer));
    T_QPlayer.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Game")) };
    T_QPlayer.base_name = "QActor";
    T_QPlayer.properties.push_back(MetaProperty{"WalkSpeed", "float", offsetof(QPlayer, WalkSpeed), MetaMap{} });
    T_QPlayer.properties.push_back(MetaProperty{"Name", "std::string", offsetof(QPlayer, Name), MetaMap{} });
    T_QPlayer.properties.push_back(MetaProperty{"Friend", "QPlayer*", offsetof(QPlayer, Friend), MetaMap{} });
    T_QPlayer.properties.push_back(MetaProperty{"Friends", "std::vector<QPlayer*>", offsetof(QPlayer, Friends), MetaMap{} });
    {
        MetaFunction F;
        F.name = "SetWalkSpeed";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QPlayer_SetWalkSpeed;
        F.params = std::vector<MetaParam>{ MetaParam{"Speed", "float"} };
        F.meta = MetaMap{};
        T_QPlayer.functions.push_back(std::move(F));
    }
    TypeInfo& T_QGcTester = R.add_type("QGcTester", sizeof(QGcTester));
    T_QGcTester.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Game")) };
    T_QGcTester.base_name = "QObject";
    T_QGcTester.properties.push_back(MetaProperty{"Roots", "std::vector<QObject*>", offsetof(QGcTester, Roots), MetaMap{} });
    T_QGcTester.properties.push_back(MetaProperty{"bUseVector", "bool", offsetof(QGcTester, bUseVector), MetaMap{} });
    {
        MetaFunction F;
        F.name = "SetUseVector";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_SetUseVector;
        F.params = std::vector<MetaParam>{ MetaParam{"bUse", "bool"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternChain";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternChain;
        F.params = std::vector<MetaParam>{ MetaParam{"Length", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternGrid";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternGrid;
        F.params = std::vector<MetaParam>{ MetaParam{"Width", "int"}, MetaParam{"Height", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternRandom";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternRandom;
        F.params = std::vector<MetaParam>{ MetaParam{"Nodes", "int"}, MetaParam{"BranchCount", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternRings";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternRings;
        F.params = std::vector<MetaParam>{ MetaParam{"Rings", "int"}, MetaParam{"RingSize", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PatternDiamond";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PatternDiamond;
        F.params = std::vector<MetaParam>{ MetaParam{"Layers", "int"}, MetaParam{"Breadth", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "ClearAll";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_ClearAll;
        F.params = std::vector<MetaParam>{ MetaParam{"bSilent", "bool"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "BreakAtDepth";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_BreakAtDepth;
        F.params = std::vector<MetaParam>{ MetaParam{"TargetDepth", "int"}, MetaParam{"Count", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "BreakPercent";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_BreakPercent;
        F.params = std::vector<MetaParam>{ MetaParam{"Percent", "double"}, MetaParam{"Depth", "int"}, MetaParam{"Seed", "int"}, MetaParam{"bSilient", "bool"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "BreakRandomEdges";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_BreakRandomEdges;
        F.params = std::vector<MetaParam>{ MetaParam{"EdgeCount", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "DetachRoots";
        F.return_type = "int";
        F.invoker = &_qmeta_invoke_QGcTester_DetachRoots;
        F.params = std::vector<MetaParam>{ MetaParam{"Count", "int"}, MetaParam{"Ratio", "double"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "PrintDepthStats";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_PrintDepthStats;
        F.params = std::vector<MetaParam>{ MetaParam{"TargetDepth", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "MeasureGc";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_MeasureGc;
        F.params = std::vector<MetaParam>{ MetaParam{"Repeats", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "Churn";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_Churn;
        F.params = std::vector<MetaParam>{ MetaParam{"Steps", "int"}, MetaParam{"AllocPerStep", "int"}, MetaParam{"BreakPct", "double"}, MetaParam{"GcEveryN", "int"}, MetaParam{"Seed", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "RepeatRandomAndCollect";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QGcTester_RepeatRandomAndCollect;
        F.params = std::vector<MetaParam>{ MetaParam{"NumSteps", "int"}, MetaParam{"NumNodes", "int"}, MetaParam{"NumBranches", "int"} };
        F.meta = MetaMap{};
        T_QGcTester.functions.push_back(std::move(F));
    }
    TypeInfo& T_QTestObject = R.add_type("QTestObject", sizeof(QTestObject));
    T_QTestObject.meta = MetaMap{ std::make_pair(std::string("Module"), std::string("Game")) };
    T_QTestObject.base_name = "QObject";
    T_QTestObject.properties.push_back(MetaProperty{"Integer", "int", offsetof(QTestObject, Integer), MetaMap{} });
    T_QTestObject.properties.push_back(MetaProperty{"Friend1", "QTestObject*", offsetof(QTestObject, Friend1), MetaMap{} });
    T_QTestObject.properties.push_back(MetaProperty{"Friend2", "QTestObject*", offsetof(QTestObject, Friend2), MetaMap{} });
    T_QTestObject.properties.push_back(MetaProperty{"Friend3", "QTestObject*", offsetof(QTestObject, Friend3), MetaMap{} });
    T_QTestObject.properties.push_back(MetaProperty{"Friend4", "QTestObject*", offsetof(QTestObject, Friend4), MetaMap{} });
    T_QTestObject.properties.push_back(MetaProperty{"Friend5", "QTestObject*", offsetof(QTestObject, Friend5), MetaMap{} });
    T_QTestObject.properties.push_back(MetaProperty{"Children", "std::vector<QTestObject*>", offsetof(QTestObject, Children), MetaMap{} });
    {
        MetaFunction F;
        F.name = "SetInteger";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QTestObject_SetInteger;
        F.params = std::vector<MetaParam>{ MetaParam{"InValue", "int"} };
        F.meta = MetaMap{};
        T_QTestObject.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "RemoveFriend";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QTestObject_RemoveFriend;
        F.params = std::vector<MetaParam>{ MetaParam{"Idx", "int"} };
        F.meta = MetaMap{};
        T_QTestObject.functions.push_back(std::move(F));
    }
    {
        MetaFunction F;
        F.name = "RemoveChildren";
        F.return_type = "void";
        F.invoker = &_qmeta_invoke_QTestObject_RemoveChildren;
        F.params = std::vector<MetaParam>{  };
        F.meta = MetaMap{};
        T_QTestObject.functions.push_back(std::move(F));
    }
}
